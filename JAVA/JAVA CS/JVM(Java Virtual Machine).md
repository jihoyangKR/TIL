# JVM(Java Virtual Machine)

자바 바이트 코드가 동작하는 JRE 에서 가장 중요한 요소.

## JVM의 역할

자바 바이트코드를 해석하고 실행한다. 자바 애플리케이션을 클래스 로더(Class Loader)를 통해 읽어 들여서 자바 API와 함께 실행한다.

JAVA는 OS에 종속적이지 않다는 특징을 가지고 있다. OS에 종속되지 않고 실행되기 위해서는 OS위에서 JAVA를 실행시킬 무언가가 필요한데 그것이 바로 JVM이다. 즉, OS에 종속받지 않고 CPU가 JAVA를 인식, 실행할 수 있게 하는 가상 컴퓨터이다. 

## JVM의 특징

- 스택 기반의 가상 머신: 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.

  - 피연산자와 연산 후 결과를 스택에 저장한다. 다음 피연산자의 메모리 위치를 기억할 필요가 없다. SP(stack pointer)가 다음 피연산자의 위치를 나타낸다. 즉 스택에서 POP만 하면 다음 피연산자가 나오기 때문에 피연산자의 메모리를 기억할 필요가 없다.
  - ![img](JVM(Java Virtual Machine).assets/img2.png)

- 심볼릭 레퍼런스

  : 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.

  - 심볼릭 레퍼런스란:
    - 참고하는 클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아니라, 참조하는 대상의 이름만을 지칭한 것이다. Class 파일이 JVM에 올라가게 되면 Symbolic Reference는 그 이름에 맞는 객체의 주소를 찾아서 연결하는 작업을 수행한다. 그러므로, 실제 메모리 주소가 아니라 이름만을 가진다.

- 가비지 컬렉션(garbage collection): 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.

- 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장: C/C++ 등의 전통적인 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.

- 네트워크 바이트 오더(network byte order): 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다. 빅 엔디안은 데이터가 상위 바이트부터 메모리에 적재하여, 가상 최상위 바이트(0A)가 가장 낮은 메모리 주소에 저장되는 방식을 의미한다.

  - 바이트 오더
    - 메모리 주소를 부여하는 방식으로, 점점 크게 부여하거나 점점 작게 부여하는 방식을 의미한다. 대표적인 예시로 빅엔디안, 리틀엔디안이라는 것이 있고, 이는 시스템이 내부적으로 데이터를 표현하는 방법을 의미한다.
    - ![img](JVM(Java Virtual Machine).assets/img.png)



## 자바 바이트 코드

WORA(Write Once Run Anywhere)를 구현하기 위해 JVM은 사용자 언어인 자바와 기계어 사이의 중간 언어인 자바 바이트코드를 사용한다. 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 다위이다.

## JVM 구조

![](JVM(Java Virtual Machine).assets/img-16520289957122.png)

JVM은 크게 아래와 같이 이루어져 있다.

- 클래스 로더(Class Loader)

  - JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈이다. 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할을 한다.

- 실행 엔진(Execution Engine)

  클래스를 실행시키는 역할이다. 클래스로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행 엔진에 의해 실행된다.

  실행 엔진은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.

  - 인터프리터(Interpreter)
  - JIT 컴파일러(Just-in-Time)
  - 가비지 콜렉터(Garbage collector)

- 런타임 데이터 영역 (Runtime Data Area)

## Memory Area(Runtime Data Area)의 구조

![img](JVM(Java Virtual Machine).assets/images%2Fshin_stealer%2Fpost%2F024b42b8-85fa-4393-9668-6ef15227a0d0%2Fimage.png)

1) Method Area

- JVM이 실행되면서 생기는 공간이다.
- Class 정보, 전역변수 정보, Static 변수 정보가 저장되는 공간이다.
- Runtime Constant Pool 에는 말 그대로 '상수' 정보가 저장되는 공간이다.
- 모든 스레드에서 정보가 공유된다.

2) Heap

- new 연산자로 생성된 객체, Array와 같은 동적으로 생성된 데이터가 저장되는 공간
- Heap에 저장된 데이터는 Garbage Collector 가 처리하지 않는한 소멸되지 않는다.
- Reference Type 의 데이터가 저장되는 공간
- 모든 스레드에서 정보가 공유된다.

3) Stack

- 지역변수, 메소드의 매개변수와 같이 잠시 사용되고 필요가 없어지는 데이터가 저장되는 공간
- Last In First Out, 나중에 들어온 데이터가 먼저 나간다
- 만약, 지역변수 이지만 Reference Type일 경우에는 Heap 에 저장된 데이터의 주소값을 Stack 에 저장해서 사용하게 된다.
- 스레드마다 하나씩 존재한다.

4) PC Register

- 스레드가 생성되면서 생기는 공간
- 스레드가 어느 명령어를 처리하고 있는지 그 주소를 등록한다.
- JVM이 실행하고 있는 현재 위치를 저장하는 역할

5) Native Method Stack

- Java 가 아닌 다른 언어 (C, C++) 로 구성된 메소드를 실행이 필요할 때 사용되는 공간